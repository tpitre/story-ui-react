/**
 * StoryUIPanel - AI-powered Storybook story generator
 *
 * Redesigned with:
 * - CSS Layers for cascade control (no !important)
 * - CSS Custom Properties for theming
 * - useReducer for state management
 * - Semantic HTML with ARIA attributes
 * - Accessible keyboard navigation
 */

import React, { useState, useEffect, useRef, useCallback, useReducer } from 'react';
import './StoryUIPanel.css';

// ============================================
// Types & Interfaces
// ============================================

interface Message {
  role: 'user' | 'ai';
  content: string;
  isStreaming?: boolean;
  streamingData?: StreamingState;
  attachedImages?: AttachedImage[];
}

interface ChatSession {
  id: string;
  title: string;
  fileName: string;
  conversation: Message[];
  lastUpdated: number;
}

interface AttachedImage {
  id: string;
  file: File;
  preview: string;
  base64: string;
  mediaType: string;
}

interface IntentPreview {
  title: string;
  components: string[];
  approach: string;
}

interface ProgressUpdate {
  phase: string;
  step: number;
  totalSteps: number;
  message: string;
}

interface ValidationFeedback {
  isValid: boolean;
  errors?: string[];
  autoFixApplied?: boolean;
}

interface RetryInfo {
  attempt: number;
  maxAttempts: number;
  reason: string;
}

interface ComponentUsage {
  name: string;
  reason?: string;
}

interface LayoutChoice {
  pattern: string;
  reason: string;
}

interface StyleChoice {
  property: string;
  value: string;
  reason?: string;
}

interface CompletionFeedback {
  success: boolean;
  storyId?: string;
  fileName?: string;
  title?: string;
  code?: string;
  summary: { action: string; details: string };
  componentsUsed: ComponentUsage[];
  layoutChoices: LayoutChoice[];
  styleChoices?: StyleChoice[];
  validation?: ValidationFeedback;
  suggestions?: string[];
  metrics?: { totalTimeMs: number; llmCallsCount: number };
}

interface ErrorFeedback {
  message: string;
  details?: string;
  suggestion?: string;
}

interface StreamingState {
  intent?: IntentPreview;
  progress?: ProgressUpdate;
  validation?: ValidationFeedback;
  retry?: RetryInfo;
  completion?: CompletionFeedback;
  error?: ErrorFeedback;
}

interface OrphanStory {
  id: string;
  title: string;
  fileName: string;
}

interface ProviderInfo {
  type: string;
  name: string;
  configured: boolean;
  models: string[];
}

interface ProvidersResponse {
  providers: ProviderInfo[];
  current?: { provider: string; model: string };
}

interface StreamEvent {
  type: 'intent' | 'progress' | 'validation' | 'retry' | 'completion' | 'error';
  data: unknown;
}

// ============================================
// State Reducer
// ============================================

interface PanelState {
  // UI state
  sidebarOpen: boolean;
  showCode: boolean;
  isDragging: boolean;
  loading: boolean;
  isBulkDeleting: boolean;

  // Data state
  conversation: Message[];
  recentChats: ChatSession[];
  orphanStories: OrphanStory[];
  activeChatId: string | null;
  activeTitle: string;

  // Input state
  input: string;
  attachedImages: AttachedImage[];
  selectedStoryIds: Set<string>;

  // Provider state
  availableProviders: ProviderInfo[];
  selectedProvider: string;
  selectedModel: string;

  // Connection state
  connectionStatus: { connected: boolean; error?: string };
  streamingState: StreamingState | null;
  error: string | null;

  // Config state
  considerations: string;
}

type PanelAction =
  | { type: 'TOGGLE_SIDEBAR' }
  | { type: 'SET_SIDEBAR'; payload: boolean }
  | { type: 'TOGGLE_CODE' }
  | { type: 'SET_DRAGGING'; payload: boolean }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_BULK_DELETING'; payload: boolean }
  | { type: 'SET_CONVERSATION'; payload: Message[] }
  | { type: 'ADD_MESSAGE'; payload: Message }
  | { type: 'SET_RECENT_CHATS'; payload: ChatSession[] }
  | { type: 'SET_ORPHAN_STORIES'; payload: OrphanStory[] }
  | { type: 'SET_ACTIVE_CHAT'; payload: { id: string | null; title: string } }
  | { type: 'SET_INPUT'; payload: string }
  | { type: 'SET_ATTACHED_IMAGES'; payload: AttachedImage[] }
  | { type: 'ADD_ATTACHED_IMAGE'; payload: AttachedImage }
  | { type: 'REMOVE_ATTACHED_IMAGE'; payload: string }
  | { type: 'CLEAR_ATTACHED_IMAGES' }
  | { type: 'SET_SELECTED_STORY_IDS'; payload: Set<string> }
  | { type: 'TOGGLE_STORY_SELECTION'; payload: string }
  | { type: 'SET_PROVIDERS'; payload: ProviderInfo[] }
  | { type: 'SET_SELECTED_PROVIDER'; payload: string }
  | { type: 'SET_SELECTED_MODEL'; payload: string }
  | { type: 'SET_CONNECTION_STATUS'; payload: { connected: boolean; error?: string } }
  | { type: 'SET_STREAMING_STATE'; payload: StreamingState | null }
  | { type: 'UPDATE_STREAMING_STATE'; payload: Partial<StreamingState> }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_CONSIDERATIONS'; payload: string }
  | { type: 'NEW_CHAT' };

const initialState: PanelState = {
  sidebarOpen: true,
  showCode: false,
  isDragging: false,
  loading: false,
  isBulkDeleting: false,
  conversation: [],
  recentChats: [],
  orphanStories: [],
  activeChatId: null,
  activeTitle: '',
  input: '',
  attachedImages: [],
  selectedStoryIds: new Set(),
  availableProviders: [],
  selectedProvider: '',
  selectedModel: '',
  connectionStatus: { connected: false },
  streamingState: null,
  error: null,
  considerations: '',
};

function panelReducer(state: PanelState, action: PanelAction): PanelState {
  switch (action.type) {
    case 'TOGGLE_SIDEBAR':
      return { ...state, sidebarOpen: !state.sidebarOpen };
    case 'SET_SIDEBAR':
      return { ...state, sidebarOpen: action.payload };
    case 'TOGGLE_CODE':
      return { ...state, showCode: !state.showCode };
    case 'SET_DRAGGING':
      return { ...state, isDragging: action.payload };
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    case 'SET_BULK_DELETING':
      return { ...state, isBulkDeleting: action.payload };
    case 'SET_CONVERSATION':
      return { ...state, conversation: action.payload };
    case 'ADD_MESSAGE':
      return { ...state, conversation: [...state.conversation, action.payload] };
    case 'SET_RECENT_CHATS':
      return { ...state, recentChats: action.payload };
    case 'SET_ORPHAN_STORIES':
      return { ...state, orphanStories: action.payload };
    case 'SET_ACTIVE_CHAT':
      return { ...state, activeChatId: action.payload.id, activeTitle: action.payload.title };
    case 'SET_INPUT':
      return { ...state, input: action.payload };
    case 'SET_ATTACHED_IMAGES':
      return { ...state, attachedImages: action.payload };
    case 'ADD_ATTACHED_IMAGE':
      return { ...state, attachedImages: [...state.attachedImages, action.payload] };
    case 'REMOVE_ATTACHED_IMAGE':
      return {
        ...state,
        attachedImages: state.attachedImages.filter(img => img.id !== action.payload),
      };
    case 'CLEAR_ATTACHED_IMAGES':
      return { ...state, attachedImages: [] };
    case 'SET_SELECTED_STORY_IDS':
      return { ...state, selectedStoryIds: action.payload };
    case 'TOGGLE_STORY_SELECTION': {
      const newSet = new Set(state.selectedStoryIds);
      if (newSet.has(action.payload)) {
        newSet.delete(action.payload);
      } else {
        newSet.add(action.payload);
      }
      return { ...state, selectedStoryIds: newSet };
    }
    case 'SET_PROVIDERS':
      return { ...state, availableProviders: action.payload };
    case 'SET_SELECTED_PROVIDER':
      return { ...state, selectedProvider: action.payload };
    case 'SET_SELECTED_MODEL':
      return { ...state, selectedModel: action.payload };
    case 'SET_CONNECTION_STATUS':
      return { ...state, connectionStatus: action.payload };
    case 'SET_STREAMING_STATE':
      return { ...state, streamingState: action.payload };
    case 'UPDATE_STREAMING_STATE':
      return { ...state, streamingState: { ...state.streamingState, ...action.payload } };
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    case 'SET_CONSIDERATIONS':
      return { ...state, considerations: action.payload };
    case 'NEW_CHAT':
      return { ...state, conversation: [], activeChatId: null, activeTitle: '' };
    default:
      return state;
  }
}

// ============================================
// Constants
// ============================================

const USE_STREAMING = true;
const MAX_RECENT_CHATS = 20;
const CHAT_STORAGE_KEY = 'story-ui-chats';
const MAX_IMAGES = 4;
const MAX_IMAGE_SIZE_MB = 20;

// ============================================
// Helper Functions
// ============================================

function getApiBaseUrl(): string {
  // Check for edge deployment URL
  if (typeof import.meta !== 'undefined' && (import.meta as any).env?.VITE_STORY_UI_EDGE_URL) {
    return (import.meta as any).env.VITE_STORY_UI_EDGE_URL;
  }

  // Check for runtime override
  if (typeof window !== 'undefined') {
    if ((window as any).__STORY_UI_EDGE_URL__) {
      return (window as any).__STORY_UI_EDGE_URL__;
    }
    // Railway detection
    if (window.location.hostname.includes('railway.app')) {
      return window.location.origin;
    }
  }

  // Get port from various sources
  let port = '4001';
  if (typeof import.meta !== 'undefined' && (import.meta as any).env?.VITE_STORY_UI_PORT) {
    port = (import.meta as any).env.VITE_STORY_UI_PORT;
  } else if (typeof window !== 'undefined') {
    if ((window as any).__STORY_UI_PORT__) {
      port = (window as any).__STORY_UI_PORT__;
    } else if ((window as any).STORY_UI_MCP_PORT) {
      port = (window as any).STORY_UI_MCP_PORT;
    }
  }

  return `http://localhost:${port}`;
}

const API_BASE = getApiBaseUrl();
const MCP_API = `${API_BASE}/mcp/generate-story`;
const MCP_STREAM_API = `${API_BASE}/mcp/generate-story-stream`;
const PROVIDERS_API = `${API_BASE}/mcp/providers`;
const STORIES_API = `${API_BASE}/story-ui/stories`;
const CONSIDERATIONS_API = `${API_BASE}/mcp/considerations`;

function isEdgeMode(): boolean {
  const baseUrl = getApiBaseUrl();
  return baseUrl.includes('railway.app') || baseUrl.includes('workers.dev');
}

function getConnectionDisplayText(): string {
  const baseUrl = getApiBaseUrl();
  if (baseUrl.includes('railway.app')) {
    return 'Railway Cloud';
  }
  if (baseUrl.includes('workers.dev')) {
    return 'Cloudflare Edge';
  }
  const port = baseUrl.match(/:(\d+)/)?.[1] || '4001';
  return `localhost:${port}`;
}

function loadChats(): ChatSession[] {
  try {
    const stored = localStorage.getItem(CHAT_STORAGE_KEY);
    if (stored) {
      return JSON.parse(stored);
    }
  } catch (e) {
    console.error('Failed to load chats:', e);
  }
  return [];
}

function saveChats(chats: ChatSession[]): void {
  try {
    localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(chats));
  } catch (e) {
    console.error('Failed to save chats:', e);
  }
}

async function testMCPConnection(): Promise<{ connected: boolean; error?: string }> {
  try {
    const response = await fetch(PROVIDERS_API, { method: 'GET' });
    if (response.ok) {
      return { connected: true };
    }
    return { connected: false, error: `Server returned ${response.status}` };
  } catch (e) {
    return { connected: false, error: 'Cannot connect to MCP server' };
  }
}

async function syncWithActualStories(): Promise<ChatSession[]> {
  try {
    const response = await fetch(STORIES_API);
    if (!response.ok) return loadChats();

    const data = await response.json();
    const serverStories = data.stories || [];
    const localChats = loadChats();
    const serverStoryIds = new Set(serverStories.map((s: any) => s.id));

    // Remove chats for deleted stories
    const syncedChats = localChats.filter(chat => serverStoryIds.has(chat.id));
    saveChats(syncedChats);
    return syncedChats;
  } catch (e) {
    return loadChats();
  }
}

async function fetchOrphanStories(): Promise<OrphanStory[]> {
  try {
    const response = await fetch(STORIES_API);
    if (!response.ok) return [];

    const data = await response.json();
    const serverStories = data.stories || [];
    const localChats = loadChats();
    const chatIds = new Set(localChats.map(c => c.id));

    return serverStories
      .filter((s: any) => !chatIds.has(s.id))
      .map((s: any) => ({ id: s.id, title: s.title, fileName: s.fileName }));
  } catch (e) {
    return [];
  }
}

async function deleteStoryAndChat(chatId: string): Promise<boolean> {
  try {
    const response = await fetch(`${STORIES_API}/${chatId}`, { method: 'DELETE' });
    if (response.ok) {
      const chats = loadChats().filter(c => c.id !== chatId);
      saveChats(chats);
      return true;
    }
    return false;
  } catch (e) {
    return false;
  }
}

function formatTime(timestamp: number): string {
  const now = Date.now();
  const diff = now - timestamp;
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);

  if (minutes < 1) return 'Just now';
  if (minutes < 60) return `${minutes}m ago`;
  if (hours < 24) return `${hours}h ago`;
  if (days < 7) return `${days}d ago`;
  return new Date(timestamp).toLocaleDateString();
}

function getModelDisplayName(model: string): string {
  const displayNames: Record<string, string> = {
    'claude-opus-4-5-20251101': 'Claude Opus 4.5',
    'claude-sonnet-4-5-20250929': 'Claude Sonnet 4.5',
    'claude-haiku-4-5-20251001': 'Claude Haiku 4.5',
    'gpt-4o': 'GPT-4o',
    'gpt-4o-mini': 'GPT-4o Mini',
    'o1': 'o1',
    'gemini-2.0-flash': 'Gemini 2.0 Flash',
    'gemini-1.5-pro': 'Gemini 1.5 Pro',
  };
  return displayNames[model] || model;
}

// ============================================
// Markdown Renderer
// ============================================

function renderMarkdown(content: string): React.ReactNode {
  const elements: React.ReactNode[] = [];
  let key = 0;

  // Replace special markers with icons
  let processedContent = content
    .replace(/\[SUCCESS\]/g, '\u2705')
    .replace(/\[ERROR\]/g, '\u274C')
    .replace(/\[TIP\]/g, '\uD83D\uDCA1')
    .replace(/\[WRENCH\]/g, '\uD83D\uDD27');

  // Split by double newlines for paragraphs
  const paragraphs = processedContent.split(/\n\n+/);

  paragraphs.forEach(paragraph => {
    if (!paragraph.trim()) return;

    // Process inline formatting
    const parts = paragraph.split(/(\*\*[^*]+\*\*|`[^`]+`|_[^_]+_)/g);

    const inlineElements = parts.map((part, i) => {
      if (part.startsWith('**') && part.endsWith('**')) {
        return <strong key={i}>{part.slice(2, -2)}</strong>;
      }
      if (part.startsWith('`') && part.endsWith('`')) {
        return <code key={i}>{part.slice(1, -1)}</code>;
      }
      if (part.startsWith('_') && part.endsWith('_')) {
        return <em key={i}>{part.slice(1, -1)}</em>;
      }
      return part;
    });

    elements.push(
      <p key={key++} className="sui-markdown">
        {inlineElements}
      </p>
    );
  });

  return <div className="sui-markdown">{elements}</div>;
}

// ============================================
// Sub-Components
// ============================================

interface StatusIndicatorProps {
  connected: boolean;
  text: string;
}

const StatusIndicator: React.FC<StatusIndicatorProps> = ({ connected, text }) => (
  <div
    className={`sui-status ${connected ? 'sui-status--connected' : 'sui-status--disconnected'}`}
    role="status"
    aria-live="polite"
  >
    <span className="sui-status__dot" aria-hidden="true" />
    <span className="sui-status__text">{text}</span>
  </div>
);

interface ProgressIndicatorProps {
  streamingState: StreamingState;
}

const ProgressIndicator: React.FC<ProgressIndicatorProps> = ({ streamingState }) => {
  const { progress, retry, completion, error } = streamingState;

  if (error) {
    return (
      <div className="sui-error" role="alert">
        <strong>{error.message}</strong>
        {error.details && <div>{error.details}</div>}
        {error.suggestion && <div>{error.suggestion}</div>}
      </div>
    );
  }

  if (completion) {
    return (
      <div className="sui-completion">
        <div className="sui-completion__header">
          <span aria-hidden="true">{completion.success ? '\u2705' : '\u274C'}</span>
          <span>{completion.summary.action}: {completion.title}</span>
        </div>
        {completion.componentsUsed.length > 0 && (
          <div className="sui-completion__components">
            {completion.componentsUsed.map((comp, i) => (
              <span key={i} className="sui-completion__tag">{comp.name}</span>
            ))}
          </div>
        )}
        {completion.metrics && (
          <div className="sui-completion__metrics">
            <span>{(completion.metrics.totalTimeMs / 1000).toFixed(1)}s</span>
            <span>{completion.metrics.llmCallsCount} LLM calls</span>
          </div>
        )}
      </div>
    );
  }

  return (
    <div className="sui-progress" role="progressbar" aria-valuenow={progress?.step} aria-valuemax={progress?.totalSteps}>
      <div className="sui-progress__header">
        <span className="sui-progress__label">
          {progress?.message || 'Generating story...'}
        </span>
        {progress && (
          <span className="sui-progress__step">{progress.step}/{progress.totalSteps}</span>
        )}
      </div>
      {progress && (
        <div className="sui-progress__bar">
          <div
            className="sui-progress__fill"
            style={{ width: `${(progress.step / progress.totalSteps) * 100}%` }}
          />
        </div>
      )}
      {retry && (
        <div className="sui-progress__retry">
          Retry {retry.attempt}/{retry.maxAttempts}: {retry.reason}
        </div>
      )}
    </div>
  );
};

// ============================================
// Icons
// ============================================

const Icons = {
  plus: (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
      <line x1="12" y1="5" x2="12" y2="19" />
      <line x1="5" y1="12" x2="19" y2="12" />
    </svg>
  ),
  chat: (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
    </svg>
  ),
  menu: (
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <line x1="3" y1="6" x2="21" y2="6" />
      <line x1="3" y1="12" x2="21" y2="12" />
      <line x1="3" y1="18" x2="21" y2="18" />
    </svg>
  ),
  close: (
    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <line x1="18" y1="6" x2="6" y2="18" />
      <line x1="6" y1="6" x2="18" y2="18" />
    </svg>
  ),
  image: (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
      <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" />
    </svg>
  ),
  send: (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
      <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
    </svg>
  ),
};

// ============================================
// Main Component
// ============================================

interface StoryUIPanelProps {
  mcpPort?: number | string;
}

function StoryUIPanel({ mcpPort }: StoryUIPanelProps) {
  const [state, dispatch] = useReducer(panelReducer, initialState);

  const chatEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const hasShownRefreshHint = useRef(false);

  // Set port override if provided
  useEffect(() => {
    if (mcpPort && typeof window !== 'undefined') {
      (window as any).STORY_UI_MCP_PORT = String(mcpPort);
    }
  }, [mcpPort]);

  // Initialize on mount
  useEffect(() => {
    const initialize = async () => {
      const connectionTest = await testMCPConnection();
      dispatch({ type: 'SET_CONNECTION_STATUS', payload: connectionTest });

      if (connectionTest.connected) {
        // Fetch providers
        try {
          const res = await fetch(PROVIDERS_API);
          if (res.ok) {
            const data: ProvidersResponse = await res.json();
            dispatch({ type: 'SET_PROVIDERS', payload: data.providers.filter(p => p.configured) });
            if (data.current) {
              dispatch({ type: 'SET_SELECTED_PROVIDER', payload: data.current.provider.toLowerCase() });
              dispatch({ type: 'SET_SELECTED_MODEL', payload: data.current.model });
            }
          }
        } catch (e) {
          console.error('Failed to fetch providers:', e);
        }

        // Fetch considerations
        try {
          const res = await fetch(CONSIDERATIONS_API);
          if (res.ok) {
            const data = await res.json();
            if (data.hasConsiderations && data.considerations) {
              dispatch({ type: 'SET_CONSIDERATIONS', payload: data.considerations });
            }
          }
        } catch (e) {
          console.error('Failed to fetch considerations:', e);
        }

        // Sync chats
        const syncedChats = await syncWithActualStories();
        const sortedChats = syncedChats.sort((a, b) => b.lastUpdated - a.lastUpdated).slice(0, MAX_RECENT_CHATS);
        dispatch({ type: 'SET_RECENT_CHATS', payload: sortedChats });

        if (sortedChats.length > 0) {
          dispatch({ type: 'SET_CONVERSATION', payload: sortedChats[0].conversation });
          dispatch({ type: 'SET_ACTIVE_CHAT', payload: { id: sortedChats[0].id, title: sortedChats[0].title } });
        }

        // Fetch orphan stories
        const orphans = await fetchOrphanStories();
        dispatch({ type: 'SET_ORPHAN_STORIES', payload: orphans });
      } else {
        const localChats = loadChats();
        dispatch({ type: 'SET_RECENT_CHATS', payload: localChats });
      }
    };

    initialize();
  }, []);

  // Scroll to bottom on new messages
  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [state.conversation, state.loading]);

  // File handling
  const fileToBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => {
        const result = reader.result as string;
        const base64 = result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = error => reject(error);
    });
  };

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files) return;

    const errors: string[] = [];

    for (let i = 0; i < files.length && (state.attachedImages.length + i) < MAX_IMAGES; i++) {
      const file = files[i];

      if (!file.type.startsWith('image/')) {
        errors.push(`${file.name}: Not an image file`);
        continue;
      }

      if (file.size > MAX_IMAGE_SIZE_MB * 1024 * 1024) {
        errors.push(`${file.name}: File too large (max ${MAX_IMAGE_SIZE_MB}MB)`);
        continue;
      }

      try {
        const base64 = await fileToBase64(file);
        const preview = URL.createObjectURL(file);

        dispatch({
          type: 'ADD_ATTACHED_IMAGE',
          payload: {
            id: `${Date.now()}-${i}`,
            file,
            preview,
            base64,
            mediaType: file.type || 'image/png',
          },
        });
      } catch (err) {
        errors.push(`${file.name}: Failed to process`);
      }
    }

    if (errors.length > 0) {
      dispatch({ type: 'SET_ERROR', payload: errors.join('\n') });
    }

    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const removeAttachedImage = (id: string) => {
    const img = state.attachedImages.find(i => i.id === id);
    if (img) {
      URL.revokeObjectURL(img.preview);
    }
    dispatch({ type: 'REMOVE_ATTACHED_IMAGE', payload: id });
  };

  const clearAttachedImages = () => {
    state.attachedImages.forEach(img => URL.revokeObjectURL(img.preview));
    dispatch({ type: 'CLEAR_ATTACHED_IMAGES' });
  };

  // Drag and drop handlers
  const handleDragEnter = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.types.includes('Files')) {
      dispatch({ type: 'SET_DRAGGING', payload: true });
    }
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (!e.currentTarget.contains(e.relatedTarget as Node)) {
      dispatch({ type: 'SET_DRAGGING', payload: false });
    }
  }, []);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
  }, []);

  const handleDrop = useCallback(async (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    dispatch({ type: 'SET_DRAGGING', payload: false });

    const files = Array.from(e.dataTransfer.files);
    const imageFiles = files.filter(f => f.type.startsWith('image/'));

    if (imageFiles.length === 0) {
      dispatch({ type: 'SET_ERROR', payload: 'Please drop image files only' });
      return;
    }

    const errors: string[] = [];

    for (let i = 0; i < imageFiles.length && (state.attachedImages.length + i) < MAX_IMAGES; i++) {
      const file = imageFiles[i];

      if (file.size > MAX_IMAGE_SIZE_MB * 1024 * 1024) {
        errors.push(`${file.name}: File too large`);
        continue;
      }

      try {
        const base64 = await fileToBase64(file);
        const preview = URL.createObjectURL(file);

        dispatch({
          type: 'ADD_ATTACHED_IMAGE',
          payload: {
            id: `${Date.now()}-${i}`,
            file,
            preview,
            base64,
            mediaType: file.type || 'image/png',
          },
        });
      } catch (err) {
        errors.push(`${file.name}: Failed to process`);
      }
    }

    if (errors.length > 0) {
      dispatch({ type: 'SET_ERROR', payload: errors.join('\n') });
    }
  }, [state.attachedImages.length]);

  // Paste handler
  const handlePaste = useCallback(async (e: React.ClipboardEvent) => {
    const items = e.clipboardData?.items;
    if (!items) return;

    const imageItems: DataTransferItem[] = [];
    for (let i = 0; i < items.length; i++) {
      if (items[i].type.startsWith('image/')) {
        imageItems.push(items[i]);
      }
    }

    if (imageItems.length === 0) return;
    e.preventDefault();

    if (state.attachedImages.length >= MAX_IMAGES) {
      dispatch({ type: 'SET_ERROR', payload: `Maximum ${MAX_IMAGES} images allowed` });
      return;
    }

    for (let i = 0; i < imageItems.length && (state.attachedImages.length + i) < MAX_IMAGES; i++) {
      const file = imageItems[i].getAsFile();
      if (!file) continue;

      try {
        const base64 = await fileToBase64(file);
        const preview = URL.createObjectURL(file);
        const timestamp = new Date().toISOString().slice(11, 19).replace(/:/g, '-');

        dispatch({
          type: 'ADD_ATTACHED_IMAGE',
          payload: {
            id: `paste-${Date.now()}-${i}`,
            file: new File([file], `pasted-image-${timestamp}.png`, { type: file.type }),
            preview,
            base64,
            mediaType: file.type || 'image/png',
          },
        });
      } catch (err) {
        dispatch({ type: 'SET_ERROR', payload: 'Failed to process pasted image' });
      }
    }
  }, [state.attachedImages.length]);

  // Build response message from completion
  const buildConversationalResponse = (completion: CompletionFeedback, isUpdate: boolean): string => {
    const parts: string[] = [];
    const statusMarker = completion.success ? '[SUCCESS]' : '[ERROR]';

    if (isUpdate) {
      parts.push(`${statusMarker} **Updated: "${completion.title}"**`);
    } else {
      parts.push(`${statusMarker} **Created: "${completion.title}"**`);
    }

    const componentCount = completion.componentsUsed?.length || 0;
    if (componentCount > 0) {
      const names = completion.componentsUsed.slice(0, 5).map(c => `\`${c.name}\``).join(', ');
      parts.push(`\nBuilt with ${names}${componentCount > 5 ? '...' : ''}.`);
    }

    if (completion.layoutChoices?.length > 0) {
      const layout = completion.layoutChoices[0];
      parts.push(`\n\n**Layout:** ${layout.pattern} - ${layout.reason}.`);
    }

    if (completion.validation?.autoFixApplied) {
      parts.push(`\n\n[WRENCH] **Auto-fixed:** Minor syntax issues were automatically corrected.`);
    }

    if (completion.suggestions && completion.suggestions.length > 0 && !completion.suggestions[0].toLowerCase().includes('review the generated code')) {
      parts.push(`\n\n[TIP] **Tip:** ${completion.suggestions[0]}`);
    }

    if (!isUpdate && !hasShownRefreshHint.current) {
      if (isEdgeMode()) {
        parts.push(`\n\n_Story saved to cloud._`);
      } else {
        parts.push(`\n\n_Might need to refresh Storybook (Cmd/Ctrl + R) to see new stories._`);
      }
      hasShownRefreshHint.current = true;
    }

    if (completion.metrics?.totalTimeMs) {
      parts.push(`\n\n_${(completion.metrics.totalTimeMs / 1000).toFixed(1)}s_`);
    }

    return parts.join('');
  };

  // Finalize streaming conversation
  const finalizeStreamingConversation = useCallback((
    newConversation: Message[],
    completion: CompletionFeedback,
    userInput: string
  ) => {
    const isUpdate = completion.summary.action === 'updated';
    const responseMessage = buildConversationalResponse(completion, isUpdate);

    const aiMsg: Message = { role: 'ai', content: responseMessage };
    const updatedConversation = [...newConversation, aiMsg];
    dispatch({ type: 'SET_CONVERSATION', payload: updatedConversation });

    const isExistingSession = state.activeChatId && state.conversation.length > 0;

    if (isExistingSession && state.activeChatId) {
      const updatedSession: ChatSession = {
        id: state.activeChatId,
        title: state.activeTitle,
        fileName: completion.fileName || state.activeChatId,
        conversation: updatedConversation,
        lastUpdated: Date.now(),
      };

      const chats = loadChats();
      const chatIndex = chats.findIndex(c => c.id === state.activeChatId);
      if (chatIndex !== -1) {
        chats[chatIndex] = updatedSession;
      }
      saveChats(chats);
      dispatch({ type: 'SET_RECENT_CHATS', payload: chats });
    } else {
      const chatId = completion.storyId || completion.fileName || Date.now().toString();
      const chatTitle = completion.title || userInput;
      dispatch({ type: 'SET_ACTIVE_CHAT', payload: { id: chatId, title: chatTitle } });

      const newSession: ChatSession = {
        id: chatId,
        title: chatTitle,
        fileName: completion.fileName || '',
        conversation: updatedConversation,
        lastUpdated: Date.now(),
      };

      const chats = loadChats().filter(c => c.id !== chatId);
      chats.unshift(newSession);
      if (chats.length > MAX_RECENT_CHATS) {
        chats.splice(MAX_RECENT_CHATS);
      }
      saveChats(chats);
      dispatch({ type: 'SET_RECENT_CHATS', payload: chats });
    }
  }, [state.activeChatId, state.activeTitle, state.conversation.length]);

  // Handle send
  const handleSend = async (e?: React.FormEvent) => {
    if (e) e.preventDefault();
    if (!state.input.trim() && state.attachedImages.length === 0) return;

    const userInput = state.input.trim() || (state.attachedImages.length > 0 ? 'Create a component that matches this design' : '');
    dispatch({ type: 'SET_ERROR', payload: null });
    dispatch({ type: 'SET_LOADING', payload: true });
    dispatch({ type: 'SET_STREAMING_STATE', payload: null });

    const connectionTest = await testMCPConnection();
    dispatch({ type: 'SET_CONNECTION_STATUS', payload: connectionTest });

    if (!connectionTest.connected) {
      dispatch({ type: 'SET_ERROR', payload: `Cannot connect to MCP server: ${connectionTest.error || 'Server not running'}` });
      dispatch({ type: 'SET_LOADING', payload: false });
      return;
    }

    const imagesToSend = [...state.attachedImages];
    const hasImages = imagesToSend.length > 0;

    const userMessage: Message = {
      role: 'user',
      content: userInput,
      attachedImages: hasImages ? imagesToSend : undefined,
    };
    const newConversation: Message[] = [...state.conversation, userMessage];
    dispatch({ type: 'SET_CONVERSATION', payload: newConversation });
    dispatch({ type: 'SET_INPUT', payload: '' });
    clearAttachedImages();

    if (USE_STREAMING) {
      try {
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
        }
        abortControllerRef.current = new AbortController();

        dispatch({ type: 'SET_STREAMING_STATE', payload: {} });

        const imagePayload = hasImages
          ? imagesToSend.map(img => ({
              type: 'base64' as const,
              data: img.base64,
              mediaType: img.file.type,
            }))
          : undefined;

        const response = await fetch(MCP_STREAM_API, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: userInput,
            conversation: newConversation,
            fileName: state.activeChatId || undefined,
            isUpdate: state.activeChatId && state.conversation.length > 0,
            originalTitle: state.activeTitle || undefined,
            storyId: state.activeChatId || undefined,
            images: imagePayload,
            visionMode: hasImages ? 'screenshot_to_story' : undefined,
            provider: state.selectedProvider || undefined,
            model: state.selectedModel || undefined,
            considerations: state.considerations || undefined,
          }),
          signal: abortControllerRef.current.signal,
        });

        if (!response.ok) {
          throw new Error(`Streaming request failed: ${response.status}`);
        }

        const reader = response.body?.getReader();
        if (!reader) {
          throw new Error('No response body');
        }

        const decoder = new TextDecoder();
        let buffer = '';
        let completionData: CompletionFeedback | null = null;
        let errorData: ErrorFeedback | null = null;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const event: StreamEvent = JSON.parse(line.slice(6));

                switch (event.type) {
                  case 'intent':
                    dispatch({ type: 'UPDATE_STREAMING_STATE', payload: { intent: event.data as IntentPreview } });
                    break;
                  case 'progress':
                    dispatch({ type: 'UPDATE_STREAMING_STATE', payload: { progress: event.data as ProgressUpdate } });
                    break;
                  case 'validation':
                    dispatch({ type: 'UPDATE_STREAMING_STATE', payload: { validation: event.data as ValidationFeedback } });
                    break;
                  case 'retry':
                    dispatch({ type: 'UPDATE_STREAMING_STATE', payload: { retry: event.data as RetryInfo } });
                    break;
                  case 'completion':
                    completionData = event.data as CompletionFeedback;
                    dispatch({ type: 'UPDATE_STREAMING_STATE', payload: { completion: completionData } });
                    break;
                  case 'error':
                    errorData = event.data as ErrorFeedback;
                    dispatch({ type: 'UPDATE_STREAMING_STATE', payload: { error: errorData } });
                    break;
                }
              } catch (parseError) {
                console.warn('Failed to parse SSE event:', line);
              }
            }
          }
        }

        if (completionData) {
          finalizeStreamingConversation(newConversation, completionData, userInput);
        } else if (errorData) {
          dispatch({ type: 'SET_ERROR', payload: errorData.message });
          const errorConversation = [...newConversation, { role: 'ai' as const, content: `Error: ${errorData.message}\n\n${errorData.suggestion || ''}` }];
          dispatch({ type: 'SET_CONVERSATION', payload: errorConversation });
        }

      } catch (err: unknown) {
        if ((err as Error).name === 'AbortError') {
          return;
        }
        console.warn('Streaming failed, falling back to non-streaming:', err);
        dispatch({ type: 'SET_STREAMING_STATE', payload: null });

        // Fallback to non-streaming
        try {
          const res = await fetch(MCP_API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: userInput,
              conversation: newConversation,
              fileName: state.activeChatId || undefined,
              provider: state.selectedProvider || undefined,
              model: state.selectedModel || undefined,
              considerations: state.considerations || undefined,
            }),
          });

          const data = await res.json();
          if (!res.ok || !data.success) throw new Error(data.error || 'Story generation failed');

          const responseMessage = `[SUCCESS] **Created: "${data.title}"**\n\nStory generated successfully.`;
          const aiMsg: Message = { role: 'ai', content: responseMessage };
          const updatedConversation = [...newConversation, aiMsg];
          dispatch({ type: 'SET_CONVERSATION', payload: updatedConversation });

        } catch (fallbackErr: unknown) {
          const errorMessage = fallbackErr instanceof Error ? fallbackErr.message : 'Unknown error';
          dispatch({ type: 'SET_ERROR', payload: errorMessage });
          const errorConversation = [...newConversation, { role: 'ai' as const, content: `Error: ${errorMessage}` }];
          dispatch({ type: 'SET_CONVERSATION', payload: errorConversation });
        }
      } finally {
        dispatch({ type: 'SET_LOADING', payload: false });
        dispatch({ type: 'SET_STREAMING_STATE', payload: null });
        abortControllerRef.current = null;
      }
    }
  };

  // Chat management handlers
  const handleSelectChat = (chat: ChatSession) => {
    dispatch({ type: 'SET_CONVERSATION', payload: chat.conversation });
    dispatch({ type: 'SET_ACTIVE_CHAT', payload: { id: chat.id, title: chat.title } });
  };

  const handleNewChat = () => {
    dispatch({ type: 'NEW_CHAT' });
  };

  const handleDeleteChat = async (chatId: string, e: React.MouseEvent) => {
    e.stopPropagation();

    if (confirm('Delete this story and chat? This action cannot be undone.')) {
      const success = await deleteStoryAndChat(chatId);

      if (success) {
        const updatedChats = state.recentChats.filter(chat => chat.id !== chatId);
        dispatch({ type: 'SET_RECENT_CHATS', payload: updatedChats });

        if (state.activeChatId === chatId) {
          if (updatedChats.length > 0) {
            dispatch({ type: 'SET_CONVERSATION', payload: updatedChats[0].conversation });
            dispatch({ type: 'SET_ACTIVE_CHAT', payload: { id: updatedChats[0].id, title: updatedChats[0].title } });
          } else {
            handleNewChat();
          }
        }
      } else {
        alert('Failed to delete story. Please try again.');
      }
    }
  };

  // Orphan story handlers
  const toggleSelectAll = () => {
    if (state.selectedStoryIds.size === state.orphanStories.length) {
      dispatch({ type: 'SET_SELECTED_STORY_IDS', payload: new Set() });
    } else {
      dispatch({ type: 'SET_SELECTED_STORY_IDS', payload: new Set(state.orphanStories.map(s => s.id)) });
    }
  };

  const handleBulkDelete = async () => {
    if (state.selectedStoryIds.size === 0) return;

    const count = state.selectedStoryIds.size;
    if (!confirm(`Delete ${count} selected ${count === 1 ? 'story' : 'stories'}?`)) return;

    dispatch({ type: 'SET_BULK_DELETING', payload: true });
    try {
      const response = await fetch(`${STORIES_API}/delete-bulk`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ids: Array.from(state.selectedStoryIds) }),
      });

      if (response.ok) {
        dispatch({ type: 'SET_ORPHAN_STORIES', payload: state.orphanStories.filter(s => !state.selectedStoryIds.has(s.id)) });
        dispatch({ type: 'SET_SELECTED_STORY_IDS', payload: new Set() });
      } else {
        alert('Failed to delete some stories.');
      }
    } catch (err) {
      alert('Failed to delete stories.');
    } finally {
      dispatch({ type: 'SET_BULK_DELETING', payload: false });
    }
  };

  const handleClearAll = async () => {
    if (state.orphanStories.length === 0) return;
    if (!confirm(`Delete ALL ${state.orphanStories.length} generated stories?`)) return;

    dispatch({ type: 'SET_BULK_DELETING', payload: true });
    try {
      const response = await fetch(STORIES_API, { method: 'DELETE' });
      if (response.ok) {
        dispatch({ type: 'SET_ORPHAN_STORIES', payload: [] });
        dispatch({ type: 'SET_SELECTED_STORY_IDS', payload: new Set() });
      } else {
        alert('Failed to clear stories.');
      }
    } catch (err) {
      alert('Failed to clear stories.');
    } finally {
      dispatch({ type: 'SET_BULK_DELETING', payload: false });
    }
  };

  const handleDeleteOrphan = async (storyId: string) => {
    try {
      const response = await fetch(`${STORIES_API}/${storyId}`, { method: 'DELETE' });
      if (response.ok) {
        dispatch({ type: 'SET_ORPHAN_STORIES', payload: state.orphanStories.filter(s => s.id !== storyId) });
        const newSet = new Set(state.selectedStoryIds);
        newSet.delete(storyId);
        dispatch({ type: 'SET_SELECTED_STORY_IDS', payload: newSet });
      }
    } catch (err) {
      console.error('Error deleting orphan story:', err);
    }
  };

  // ============================================
  // Render
  // ============================================

  return (
    <div className="sui-panel">
      {/* Sidebar */}
      <aside
        className={`sui-sidebar ${state.sidebarOpen ? '' : 'sui-sidebar--collapsed'}`}
        aria-label="Chat history"
      >
        {state.sidebarOpen ? (
          <div className="sui-sidebar__content">
            {/* Toggle button */}
            <button
              className="sui-btn sui-btn--ghost"
              onClick={() => dispatch({ type: 'TOGGLE_SIDEBAR' })}
              aria-label="Collapse sidebar"
              style={{ width: '100%', marginBottom: '12px' }}
            >
              {Icons.chat}
              <span>Chats</span>
            </button>

            {/* New Chat button */}
            <button
              className="sui-btn sui-btn--primary sui-btn--new-chat"
              onClick={handleNewChat}
            >
              {Icons.plus}
              <span>New Chat</span>
            </button>

            {/* Recent chats */}
            {state.recentChats.length > 0 && (
              <>
                <div className="sui-sidebar__section-title">Recent Chats</div>
                {state.recentChats.map(chat => (
                  <div
                    key={chat.id}
                    className={`sui-chat-item ${state.activeChatId === chat.id ? 'sui-chat-item--active' : ''}`}
                    onClick={() => handleSelectChat(chat)}
                    role="button"
                    tabIndex={0}
                    onKeyDown={e => e.key === 'Enter' && handleSelectChat(chat)}
                    aria-current={state.activeChatId === chat.id ? 'true' : undefined}
                  >
                    <div className="sui-chat-item__content">
                      <div className="sui-chat-item__title">{chat.title}</div>
                      <div className="sui-chat-item__meta">{formatTime(chat.lastUpdated)}</div>
                    </div>
                    <button
                      className="sui-chat-item__delete"
                      onClick={e => handleDeleteChat(chat.id, e)}
                      aria-label={`Delete ${chat.title}`}
                    >
                      {Icons.close}
                    </button>
                  </div>
                ))}
              </>
            )}

            {/* Orphan stories */}
            {state.orphanStories.length > 0 && (
              <>
                <div className="sui-sidebar__section-title sui-flex sui-items-center sui-gap-sm">
                  <input
                    type="checkbox"
                    className="sui-checkbox"
                    checked={state.selectedStoryIds.size === state.orphanStories.length}
                    onChange={toggleSelectAll}
                    aria-label="Select all stories"
                  />
                  <span>Generated Files ({state.orphanStories.length})</span>
                </div>

                {state.selectedStoryIds.size > 0 && (
                  <button
                    className="sui-btn sui-btn--danger"
                    onClick={handleBulkDelete}
                    disabled={state.isBulkDeleting}
                    style={{ width: '100%', marginBottom: '8px' }}
                  >
                    {state.isBulkDeleting ? 'Deleting...' : `Delete Selected (${state.selectedStoryIds.size})`}
                  </button>
                )}

                <button
                  className="sui-btn sui-btn--ghost"
                  onClick={handleClearAll}
                  disabled={state.isBulkDeleting}
                  style={{ width: '100%', marginBottom: '12px' }}
                >
                  Clear All Stories
                </button>

                {state.orphanStories.map(story => (
                  <div
                    key={story.id}
                    className={`sui-chat-item sui-orphan-item ${state.selectedStoryIds.has(story.id) ? 'sui-orphan-item--selected' : ''}`}
                  >
                    <input
                      type="checkbox"
                      className="sui-checkbox"
                      checked={state.selectedStoryIds.has(story.id)}
                      onChange={() => dispatch({ type: 'TOGGLE_STORY_SELECTION', payload: story.id })}
                      onClick={e => e.stopPropagation()}
                      aria-label={`Select ${story.title}`}
                    />
                    <div className="sui-chat-item__content">
                      <div className="sui-chat-item__title">{story.title}</div>
                      <div className="sui-chat-item__meta">{story.fileName}</div>
                    </div>
                    <button
                      className="sui-chat-item__delete"
                      onClick={() => handleDeleteOrphan(story.id)}
                      aria-label={`Delete ${story.title}`}
                    >
                      {Icons.close}
                    </button>
                  </div>
                ))}
              </>
            )}
          </div>
        ) : (
          <div style={{ padding: '8px', display: 'flex', justifyContent: 'center' }}>
            <button
              className="sui-btn sui-btn--icon sui-btn--primary"
              onClick={() => dispatch({ type: 'SET_SIDEBAR', payload: true })}
              aria-label="Expand sidebar"
            >
              {Icons.menu}
            </button>
          </div>
        )}
      </aside>

      {/* Main content */}
      <main
        className="sui-main"
        onDragEnter={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
      >
        {/* Drop overlay */}
        {state.isDragging && (
          <div className="sui-drop-overlay">
            <div className="sui-drop-overlay__text">
              {Icons.image}
              Drop images here
            </div>
          </div>
        )}

        {/* Header */}
        <header className="sui-header">
          <h1 className="sui-header__title">Story UI</h1>
          <p className="sui-header__subtitle">Generate Storybook stories with AI</p>

          <StatusIndicator
            connected={state.connectionStatus.connected}
            text={state.connectionStatus.connected
              ? `Connected to ${getConnectionDisplayText()}`
              : `Disconnected: ${state.connectionStatus.error || 'Server not running'}`
            }
          />

          {/* Provider/Model selectors */}
          {state.connectionStatus.connected && state.availableProviders.length > 0 && (
            <div className="sui-header__controls">
              <div className="sui-selector">
                <label className="sui-selector__label" htmlFor="provider-select">Provider:</label>
                <select
                  id="provider-select"
                  className="sui-selector__input"
                  value={state.selectedProvider}
                  onChange={e => {
                    const newProvider = e.target.value;
                    dispatch({ type: 'SET_SELECTED_PROVIDER', payload: newProvider });
                    const provider = state.availableProviders.find(p => p.type === newProvider);
                    if (provider?.models.length) {
                      dispatch({ type: 'SET_SELECTED_MODEL', payload: provider.models[0] });
                    }
                  }}
                >
                  {state.availableProviders.map(p => (
                    <option key={p.type} value={p.type}>{p.name}</option>
                  ))}
                </select>
              </div>
              <div className="sui-selector">
                <label className="sui-selector__label" htmlFor="model-select">Model:</label>
                <select
                  id="model-select"
                  className="sui-selector__input"
                  value={state.selectedModel}
                  onChange={e => dispatch({ type: 'SET_SELECTED_MODEL', payload: e.target.value })}
                >
                  {state.availableProviders
                    .find(p => p.type === state.selectedProvider)
                    ?.models.map(model => (
                      <option key={model} value={model}>{getModelDisplayName(model)}</option>
                    ))}
                </select>
              </div>
            </div>
          )}
        </header>

        {/* Chat area */}
        <section className="sui-chat" role="log" aria-live="polite" aria-label="Chat messages">
          {state.error && (
            <div className="sui-error" role="alert">{state.error}</div>
          )}

          {state.conversation.length === 0 && !state.loading && (
            <div className="sui-empty">
              <div className="sui-empty__title">Start a new conversation</div>
              <div className="sui-empty__subtitle">
                Describe the UI component you'd like to create
              </div>
            </div>
          )}

          {state.conversation.map((msg, i) => (
            <article
              key={i}
              className={`sui-message ${msg.role === 'user' ? 'sui-message--user' : 'sui-message--ai'}`}
            >
              <div className="sui-message__bubble">
                {msg.role === 'ai' ? renderMarkdown(msg.content) : msg.content}
                {msg.role === 'user' && msg.attachedImages && msg.attachedImages.length > 0 && (
                  <div className="sui-message__images">
                    {msg.attachedImages.map(img => (
                      <img
                        key={img.id}
                        src={img.base64 ? `data:${img.mediaType};base64,${img.base64}` : img.preview}
                        alt="attached"
                        className="sui-message__image"
                      />
                    ))}
                  </div>
                )}
              </div>
            </article>
          ))}

          {state.loading && (
            <div className="sui-message sui-message--ai">
              {state.streamingState ? (
                <ProgressIndicator streamingState={state.streamingState} />
              ) : (
                <div className="sui-progress">
                  <span>Generating story</span>
                  <span className="sui-loading-dots" />
                </div>
              )}
            </div>
          )}

          <div ref={chatEndRef} />
        </section>

        {/* Input area */}
        <div className="sui-input-area">
          {/* Hidden file input */}
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            multiple
            style={{ display: 'none' }}
            onChange={handleFileSelect}
            aria-hidden="true"
          />

          {/* Image previews */}
          {state.attachedImages.length > 0 && (
            <div className="sui-image-preview">
              <span className="sui-image-preview__label">
                {Icons.image}
                {state.attachedImages.length} image{state.attachedImages.length > 1 ? 's' : ''} attached
              </span>
              {state.attachedImages.map(img => (
                <div key={img.id} className="sui-image-preview__item">
                  <img src={img.preview} alt="preview" className="sui-image-preview__img" />
                  <button
                    className="sui-image-preview__remove"
                    onClick={() => removeAttachedImage(img.id)}
                    aria-label="Remove image"
                  >
                    {Icons.close}
                  </button>
                </div>
              ))}
            </div>
          )}

          {/* Input form */}
          <form
            onSubmit={handleSend}
            className="sui-input-form"
            style={state.attachedImages.length > 0 ? { borderTopLeftRadius: 0, borderTopRightRadius: 0 } : undefined}
          >
            <button
              type="button"
              className="sui-input-form__upload"
              onClick={() => fileInputRef.current?.click()}
              disabled={state.loading || state.attachedImages.length >= MAX_IMAGES}
              aria-label="Attach images"
            >
              {Icons.image}
            </button>

            <input
              ref={inputRef}
              type="text"
              className="sui-input-form__input"
              value={state.input}
              onChange={e => dispatch({ type: 'SET_INPUT', payload: e.target.value })}
              onPaste={handlePaste}
              placeholder={state.attachedImages.length > 0
                ? "Describe what to create from these images..."
                : "Describe a UI component..."
              }
              aria-label="Message input"
            />

            <button
              type="submit"
              className="sui-input-form__send"
              disabled={state.loading || (!state.input.trim() && state.attachedImages.length === 0)}
              aria-label="Send message"
            >
              {Icons.send}
              <span>Send</span>
            </button>
          </form>
        </div>
      </main>
    </div>
  );
}

export default StoryUIPanel;
export { StoryUIPanel };
